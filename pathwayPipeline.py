import os
import pandas as pd
import pathway as pw
from pathway import this
from pathway.xpacks.llm.document_store import DocumentStore
from pathway.xpacks.llm.splitters import TokenCountSplitter
from pathway.xpacks.llm import embedders
from pathway.stdlib.indexing.nearest_neighbors import BruteForceKnnFactory
from dotenv import load_dotenv
from google import genai
from weather import get_weather

# -----------------------------
# Load Gemini API Key
# -----------------------------
load_dotenv()
client = genai.Client(api_key=os.environ["GEMINI_API_KEY"])

# -----------------------------
# 1️⃣ Prepare CSV (combine + keep structured fields)
# -----------------------------
csv_path = "./highways/highways.csv"
df = pd.read_csv(csv_path)

# Create combined text field for embeddings
df["data"] = df.apply(
    lambda row: f"Highway: {row['highway_name']}, From: {row['start_city']}, To: {row['end_city']}, Distance: {row['distance_km']} km, Notes: {row['notes']}",
    axis=1
)

# Save structured CSV with extra fields
temp_csv_path = "./highways/highways_full.csv"
df[["data", "start_city", "end_city"]].to_csv(temp_csv_path, index=False)

# -----------------------------
# 2️⃣ Define Pathway schema
# -----------------------------
class HighwaySchema(pw.Schema):
    data: str
    start_city: str
    end_city: str

# -----------------------------
# 3️⃣ Load CSV via Pathway connector
# -----------------------------
documents = pw.io.csv.read(
    path=temp_csv_path,
    schema=HighwaySchema,
    mode="static"
)

# -----------------------------
# 4️⃣ Pathway Components
# -----------------------------
text_splitter = TokenCountSplitter(
    min_tokens=50,
    max_tokens=200,
    encoding_name="cl100k_base"
)

embedder = embedders.GeminiEmbedder(model="models/text-embedding-004")

# -----------------------------
# 5️⃣ Document Store
# -----------------------------
document_store = DocumentStore(
    docs=documents.select(data=this.data),   # only embed `data`
    retriever_factory=BruteForceKnnFactory(embedder=embedder),
    splitter=text_splitter
)

# -----------------------------
# 6️⃣ Retrieval Functions
# -----------------------------
def get_relevant_docs(query, k=3):
    t = pw.debug.table_from_markdown('''
filepath_globpattern  metadata_filter  k  query
./highways/*           None             0  dummy
''')

    t = t.select(
        filepath_globpattern="./highways/*",
        metadata_filter=None,
        k=int(k),
        query=query
    )

    retrieved = document_store.retrieve_query(
        retrieval_queries=t.select(
            filepath_globpattern=this.filepath_globpattern,
            metadata_filter=this.metadata_filter,
            k=this.k,
            query=this.query
        )
    )

    return pw.debug.table_to_pandas(retrieved.select(docs=this.result))


def get_all_docs(k=1000):
    t = pw.debug.table_from_markdown('''
filepath_globpattern  metadata_filter  k  query
./highways/*           None             0  dummy
''')

    t = t.select(
        filepath_globpattern="./highways/*",
        metadata_filter=None,
        k=int(k),
        query="all"
    )

    retrieved = document_store.retrieve_query(
        retrieval_queries=t.select(
            filepath_globpattern=this.filepath_globpattern,
            metadata_filter=this.metadata_filter,
            k=this.k,
            query=this.query
        )
    )

    return pw.debug.table_to_pandas(retrieved.select(docs=this.result))

# -----------------------------
# 7️⃣ Main Query Function
# -----------------------------
def answer_query(query, cities=None, k=3):
    retrieved_docs = get_relevant_docs(query, k=k)
    context_docs = "\n\n".join([str(doc) for doc in retrieved_docs["docs"].tolist()])

    context_weather = ""
    if cities:
        weather_info = []
        for city in cities:
            try:
                desc, temp = get_weather(city)
                weather_info.append(f"{city}: {desc}, {temp}°C")
            except Exception:
                weather_info.append(f"{city}: Weather unavailable")
        context_weather = "Live weather along the route:\n" + "\n".join(weather_info)

    prompt = f"""
You are a travel assistant. Use the following context from highway CSVs to answer:

Context:
{context_docs}

User query: {query}

{context_weather if context_weather else ""}
Provide only the requested output.
"""

    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=prompt
    )

    # ✅ Always extract something
    if hasattr(response, "text") and response.text:
        return response.text.strip()
    elif hasattr(response, "candidates") and response.candidates:
        return response.candidates[0].content.parts[0].text.strip()
    else:
        return "⚠️ No response generated by the model."